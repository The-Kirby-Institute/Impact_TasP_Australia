---
title: "Impact of U=U in Australia (skeleton)"
#date: Current draft produced `r format(Sys.Date(), format="%B %d, %Y")`.
author:
  - Richard T. Gray # PhD:
      # email: Rgray@kirby.unsw.edu.au
      # institute: [KI]
      # correspondence: true
# institute: 
#    - KI: 
#       name: The Kirby Institute, UNSW Sydney, Sydney NSW 2052, Australia
#       address: Level 6, Wallace Wurth Building High Street, UNSW Sydney Kensington NSW 2052
format:
  docx:
    reference-doc: "C:/Users/rgray/OneDrive - UNSW/R/LeftysRstuff/Rmarkdown/mystyles_Paper.docx"
    number-sections: false
    page-width: 8.25
    filters: 
      #   - pagebreak.lua
      #   - scholarly-metadata.lua
      #   - author-info-blocks.lua
      - C:/Users/rgray/OneDrive - UNSW/R/LeftysRstuff/Rmarkdown/filters/pagebreak.lua
      - C:/Users/rgray/OneDrive - UNSW/R/LeftysRstuff/Rmarkdown/filters/scholarly-metadata.lua
      - C:/Users/rgray/OneDrive - UNSW/R/LeftysRstuff/Rmarkdown/filters/author-info-blocks.lua
      
editor: visual
execute:
  include: false
  echo: false
  warning: false
  message: false
editor_options:
  markdown:
    wrap: 80
  canonical: true
bibliography: references.bib
csl: the-lancet.csl
---

<!--- Frontmatter that I can't put into Yaml (as far as I can tell) --->

The Kirby Institute, UNSW Sydney, Sydney, NSW, Australia.

Current draft produced `r format(Sys.Date(), format="%B %d, %Y")`.

**Manuscript details**

-   Word count abstract:
-   Word count main text:
-   References:
-   Figures: 1
-   Tables: 4

Skeleton of the U=U paper invited by the journal Sexual Health. Only a simple
model is used so this Quarto document contains the code and results generation.
The majority of the manuscript is written here to enable results to be inserted.
The write-up of the results for the abstract is done at the start of the Results
section. Final editing needs to be completed in the resulting Word Document file
to finalise the manuscript. This includes moving the abstract results and
reformatting the tables, and moving and reformatting the table and figure
captions.

<!--- The following code chunks set up the model and results generation for the paper--->

\newpage

## Abstract

**Background**:

**Methods**:

**Results**:

**Conclusions**:

## Introduction

-   Intro to treatment as prevention

-   Previous work on cost-effectiveness of ART but not previously done in
    Australia

-   Intro to Australia guidelines

-   Intro to study

```{r Set-up}
# Open as a project (setting working directory to source and restarting R)

# Load standard libraries and options
library(tidyverse)
library(LeftysRpkg)
library(scales)
library(cowplot) # Note this masks ggsave with save_plot
library(captioner)
library(stringr)
library(svglite)

# Set-up directories
basePath <- getwd() 
dataFolder <- file.path(basePath, "data")
resultsFolder <- file.path(basePath, "output")

# Set-up overarching variables 
currTime <- format(Sys.time(), "%y-%m-%d_%H-%M-%S") # for appending to 
# output files
```

```{r Simulation specification parameters}
# User inputs for running code. Defaults are to run everything from scratch. 

# Specifications for loading previously generated results or saving results
# to file. The basic format of a file string is: currTime_saveFileTag.Rda 

# The defaults are set to FALSE and the user has to manually specify the file 
# to load. This is set up so long simulation runs do not need to be repeated.

# Manually enter file name tag to regenerate old results
loadFileTag <- "23-03-13_01-16-16_Impact_Tasp" # set to NULL to run things from scratch

if (is.null(loadFileTag)) {
  # Set to default values 
  loadProject <- FALSE    # set to FALSE to run things a fresh.
  loadParameters <- FALSE # set to FALSE to reload and re-generate parameter sets
  loadResults <- FALSE    # set to FALSE to generate new results 
  
  useSeed <- FALSE        # set to FALSE to create new seed for generating results
  
  saveProject <- FALSE    # save project, parameters, and results files
  
} else {
  
  # Manually specify values to re-generate what you want------------------------
  
  # If any of the following are TRUE the corresponding project and results files
  # need to exist. 
  loadProject <- TRUE    # Set to TRUE to load in project specifications
  loadParameters <- TRUE # Set to TRUE to load in parameters and parameter sets
  loadResults <- TRUE    # Set to TRUE to load in results
  
  loadParameters <- ifelse(!loadProject, FALSE, loadParameters)
  loadResults <- ifelse(!loadProject, FALSE, loadResults)
  
  useSeed <- TRUE  # Set to true to use seed in project file else create new one  
  
  saveProject <- TRUE    # save project, parameters, and results files
  
}

# Store specifications in a list
simSpecs <- tibble::lst(loadFileTag, loadProject, loadParameters, loadResults, 
  useSeed, saveProject)

# Results output options

savePlots <- TRUE    # save plots to file
saveFormat <- ".svg" # Format for saving plots

```

```{r User specified analysis variables}

# User specified analysis variables---------------------------------------------

# Depending on value of loadProject enter specifications for the analysis

if (!loadProject) {
  # If not loading from previously created file specify analysis inputs for 
  # running the calculations
  
  name <- "Impact_TasP_Australia-Testing" 
  saveFileTag <- "Impact_Tasp"
  
  loadFileTag <- paste0(currTime, "_", saveFileTag)
  
  startYear <- 2009 
  endYear <- 2019  
  
  indexYearART <- 2010 # Year ART is held fixed for counter-factual scenario
  
  years <- startYear:endYear
  nyears <- length(years)
  
  numsims <- 1000 # number of sampled parameter sets to run
  # Set to 0 or 1 to just do best fit parameters
  # Recommended for initial sims to make sure things work
  
  # Generate and store a random integer for set.seed so we can rerun 
  # things exactly if we want to
  currseed <- sample(1:10^6, 1)
  set.seed(currseed)
  
  projectVars <- tibble::lst(currTime, name, saveFileTag, loadFileTag, 
    startYear, endYear, indexYearART, years, nyears, numsims, currseed)
  
  # Create parameter csv files if they don't already exist - if created they are
  # empty for user to input values
  if (!file.exists(file.path(resultsFolder, paste0(saveFileTag, 
    "_parameters_fixed.csv")))){
    
    paramsVector <- c(
      "effart" = "Effectiveness of ART", 
      "effprep" = "Effectiveness of PrEP", 
      "effcondom" = "Effectiveness of condom use",
      "annual_cost" = "Annual care and treatment cost",
      "lifetime_cost_0d" = "Lifetime care and treatment cost (0% discounting)", 
      "lifetime_cost_35d" = "Lifetime care and treatment cost (3.5% discounting)",
      "lifetime_cost_50d" = "Lifetime care and treatment cost (5.0% discounting)",
      "plhiv_range" = "Range in PLHIV estimates",
      "prop_diagnosed_range" = "Range in proportion diagnosed", 
      "prop_art_range" = "Range in ART coverage",
      "prop_vs_range" = "Range in viral suppression estimates",
      "prop_prep_range" = "Range in PrEP coverage",
      "prop_condom_range" = "Range in condom use",
      "diagnosed_os_range" = "Range in diagnoses from overseas", 
      "diagnoses_range" = "Range in diagnoses",
      "inflation_index_factor" = "Inflation index factor (adjustment of annual CPI)", 
    ) 
    
    paramsFixed <- tibble(
      parameter = unname(paramsVector),
      estimate = rep('', length(paramsVector)),
      lower = rep('', length(paramsVector)),
      upper = rep('', length(paramsVector)),
      code_variable = names(paramsVector), 
      notes = rep('', length(paramsVector)), 
    )
    
    write_csv(paramsFixed , file.path(resultsFolder, paste0(saveFileTag, 
      "_parameters_fixed.csv")))
    
    # Now do time varying file
    paramsTime <- tibble(
      year = years,
      plhiv = rep('', nyears), 
      prop_diagnosed = rep('', nyears),
      prop_art = rep('', nyears),
      prop_vs = rep('', nyears),
      prop_prep = rep('', nyears),
      prop_condoms = rep('', nyears),
      diagnosed_os = rep('', nyears),
      diagoses = rep('', nyears),
      inflation = rep('', nyears)
    )
    
    write_csv(paramsTime, file.path(resultsFolder, paste0(saveFileTag, 
      "_parameters_variable.csv")))
    
  }
  
  # Save all final analysis specifications in a list -----------------------------
  project <- tibble::lst(currTime, simSpecs, projectVars)
  
  if (saveProject) {
    save(project, file = file.path(resultsFolder, 
      paste0(loadFileTag, "_project.Rda")))
  }
  
} else {
  # Load previously generated project â€” to do this we need to save current 
  # simSpecs from the previous chunk and then restore them because they will be 
  # over written when loading the project 
  
  oldSimSpecs <- simSpecs
  
  load(file.path(resultsFolder, paste0(loadFileTag, "_project.Rda")))
  
  simSpecs <- oldSimSpecs
  project$simSpecs <- simSpecs
  
  if (useSeed) {
    # Reset seed 
    set.seed(project$projectVars$currseed)
  } else {
    # Generate a new one
    currseed <- sample(1:10^6, 1)
    set.seed(currseed)
  }
  
}
```

## Methods

We used a risk equation model to estimate the annual number of new HIV
infections among GBMSM in Australia over the period 2009-2019. The approach
expands on teh methods of previous analyses looking at the impact of ART and
PrEP on HIV infections.[@kelly_hiv_2015; @gray_funding_2017;
@scott_achieving_nodate] The period of analysis ranges from prior to the
publication of the HPTN 052 clinical trial results in mid-2011
[@cohen_prevention_2011] to the start of the COVID-19 pandemic.

For this analysis we focused on GBMSM living with HIV in Australia because they
make up the majority of people with HIV in Australia and use treatment and with
undetectable viral load as a risk reduction strategy
[@holt_community-level_2018]. For simplicity we did not stratify this population
by risk behaviours for HIV acquisition prior to infection or transmission to
susceptible sexual partners and considered the overall population level effects
of changing HIV treatment coverage, sexual behaviour and primary prevention coverage, and the scale-up of PrEP.

#### Model equations

To estimate the number of people living with HIV overtime we used the following
difference equation

$$ 
N_{t+1} = N_{t} + I_{t} + N^{o}_{t}, 
$$ {#eq-plhiv}

where $N_t$ is the number of people living with HIV in year $t$, $I_t$ is the
number of new HIV infections in year $t$, and $N^o_t$ is the number of people
living with HIV arriving from overseas in year $t$.

To calculate the number of new HIV infections in Australia each year we derived
an equation that incorporates the effects of viral suppression due to treatment,
HIV PrEP, and changes in sexual behaviour on transmission. First we assume the
probability for a person with HIV with unsuppressed virus to transmit HIV to
another person is fixed over time (denoted by $\beta$ per person per year). If
no one is on effective treatment or PrEP and there is no change in prevention
strategies or sexual behaviour the number of new infections in year $t$ is 
$I_t = N_t \beta$.

People with viral suppression through effective ART have a lower probability of
transmission given by a factor $(1-\epsilon_{ART})$. The concept of undetectable
equalling transmittable or U=U is based on the the efficacy of viral suppression
$\epsilon_{ART}$ being 100%. However, at the population level where there might
not be perfect adherence and viral blips can occur this efficacy will be high
but less than 100% *\[refs\]*. We assumed $\epsilon_{ART}$ was
`r FormatPercent(100*(parametersFixed %>% filter(code_variable == "effart"))$estimate, places =0)`
with range of
`r FormatData(100*(parametersFixed %>% filter(code_variable == "effart"))$lower, places =0)` -
`r FormatPercent(100*(parametersFixed %>% filter(code_variable == "effart"))$upper, places =0)`
. If in year $t$, the proportion of people with HIV diagnosed is $d_t$, the
proportion diagnosed on ART is $\theta_t$ and the proportion treated with viral
suppression is $\psi_t$ (following the HIV cascade steps) then the overall
proportion virally suppressed will be $d_t\theta_t\psi_t$ and the value of
$\beta$ will be reduced by a factor $(1-d_t\theta_t\psi_t\epsilon_{ART})$.

If a proportion $p_t$ of the susceptible population is taking PrEP in year $t$
then there will be a similar reduction in beta due to the efficacy of PrEP
\[$\epsilon_{PrEP}$; assumed to be\
`r FormatRangePercent(100*(parametersFixed %>% filter(code_variable == "effprep"))$estimate, 100*(parametersFixed %>% filter(code_variable == "effprep"))$lower, 100*(parametersFixed %>% filter(code_variable == "effprep"))$upper, places = 0)`\] *\[refs\]*
given by $(1-p_t \epsilon_{PrEP})$.

To consider the effects of changes in sexual behaviour and the impact of other
prevention strategies on transmission over time we incorporated the effect of
changing condom use. If condoms are used a proportion $c_0$ of the time in the
initial year $t=1$ (`r project$projectVars$startYear` for our analysis) with an
effectiveness of $\epsilon_c$ but in year $t$ there is a condom usage of $c_t$
then the relative change in transmission on average will be given by the
relative factor $(1-c_t\epsilon_c)/(1-c_0\epsilon_c)$ for the overall
population.

Combining each of these effects for viral suppression, PrEP, and the relative
change in condom use gives the following equation for the number of new
infections each year $$
I_{t+1} = N_t\beta(1-d_t\theta_t\psi_t\epsilon_s)(1-p_t \epsilon_p)\frac{(1-c_t \epsilon_c)}{(1-c_0\epsilon_c)}.
$$ {#eq-incidence}

From initial estimates for $N_0$, $I_0$, and $N^o_0$ for the first year $t=1$
and appropriate data/parameter inputs the model can then use @eq-plhiv and
@eq-incidence to iterate over each year and obtain estimates for the number of
people living with HIV and the number of new HIV infections each year.

#### Input parameters

The model has three parameters that are fixed over time $\epsilon_{ART}$,
$\epsilon_{PrEP}$, and $\epsilon_c$. These are all biologically basedwe
specified a best estimate and a uniform range of values based on empirical data
(see @tbl-table1). The majority of inputs can vary over time and require an
estimate for each year for the period of analysis 2009-2019.

Estimates for each step of the HIV cascade for GBMSM were obtained from national 
surveillance which reports estimates for each step of the cascade. 

* Sentence proportion diagnoses
* Sentence % on ART from Gay Community Periodic Surveys 
* Proportion suppressed from AHOD ($<200$ cells/$\micro$l)

The coverage of PrEP in the overall GBMSM population was estimated using data
reported in the Australian Trends in Behaviour Report which collates data from
Gay Community Periodic Surveys across Australia. Coverage obtained by
multiplying the proportion eligible for PrEP by the proportion who take PrEP.

For estimates of condom use we used the measure of consistent condom use from
the Australian Trends in Behaviour Report. While this measure is not necessarily
ideal because teh model uses a ratio and incorporates the relative change. We
think this measure provides a reasonble measure for the change in sexual
behaviour over time following the ... and the scale-up of PrEP.

* Generation of sampled sets. For each fixed parameter we sampled 1000 parameter
from the ranges specified in @tbl-table1 sets. We generated uncertainty in the
time varying parameters by specifying a range in the yearly values using an
assumed multiplicative factor. Uncertainty values for each year were then
generated by sampling a value for the start and years of the period and joining
them linearly.

* To run the calculations using Eqs. @eq-plhiv and @eq-incidence requires an
initial estimate for $N_1$, $I_1$ and $N^o_1$ corresponding to the year 2009.
* We used the estimated number of people with HIV in 2009 for $N_1$.
* To initialize new infections we used the reported number of notifications for HIV 
excluding those previously diagnosed overseas in 2009 

this assumption has been validated
in previous modelling studies [ref ],

* Estimates of PLHIV and reported diagnoses excluding those previously diagnosed overseas
for 2009-2019 were used for model validation.

#### HIV treatment costs

A recent health economics study provides estimates for the lifetime cost of
providing HIV care and treatment to people living with HIV in 2019 AUD *[ref]*.
The estimated cost varied from an undiscounted cost of A$XXXX to A$XXX with 5%
discounting. The study also estimated the short- to medium-term cost which can
be used to estimate the annual cost of providing care and treatment. We used the
undiscounted 10-year costing to estimate the annual cost in 2019.

To estimate respective costs for each year prior to 2019 ....



* Considered different inflation scenarios.  

* Paragraph describing the calculations: number of people on ART * annual cost
for each inflations scenario and number of new infections * lifetime cost for
each inflation and discounting assumption

#### Calculation scenarios

* Health provider perspective

To estimate the impact and costs associated with the earlier initiation of ART
we simulated two scenarios using Eqs. @eq-plhiv and @eq-incidence. The first
scenario represents the status-qup/baseline ... the second scenario assumes the
level of ART coverage among the diagnosed population $\theta_t$ did not increase
since the time treatment as prevention became established as a prevention
strategy... assumed this was from 2012... 

* For this year the proportion of all GBMSM on ART was 
`r `
. 

#### Model outputs

Results were obtained for the best estimate inputs and from summary statistics
for the all simulations. Total costs are in 2019 AUD and rounded to the nearest
A\$1 million/\$A10,000. All analyses and results were generated using R version
XXXX with reproducible code available in an open access repository along with
input parameters and the final results \[ref Github\].

```{r Useful functions}
# This chunk sources useful functions for the set-up and analysis

# Functions to create cumulative inflation indices for each year
IndexCPI <- function(cpi) {
  
  n <- length(cpi)
  index <- rep(1, n)
  
  for (ii in 1:(n-1)) {
    index[ii] = 
      1 / prod(cpi[ii:(n-1)])
  }
  
  return(index)
  
}  

# Function to adjust inflation by an overall factor
MultiplyCPI <- function(cpiIndex, factor) {
  return(factor*(cpiIndex-1)+1 )
}

# Define some useful functions for formatting results---------------------------
decimalMark <- "low" 

FormatRange <- function(value, low, up, places = 0) {
    FormatData(value, places = places, lower = low, upper = up, 
      rangestr = "range: ")
} 

FormatRangeDecimal <- function(value, low, up, places = 1) {
  FormatData(value, lower = low, upper = up, places = places, 
    rangestr = "range: ", decimal = decimalMark)
}

FormatRangePercent <- function(value, low, up, places = 1) {
  FormatData(value, lower = low, upper = up, places = places, 
    suffix = "%", rangestr = "range: ", decimal = decimalMark)
}

Format95 <- function(value, low, up, places = 2) {
  FormatData(value, lower = low, upper = up, rangestr = "95% PI: ", 
    places = places, decimal = decimalMark)
}
  
FormatPercent <- function(value, places = 2) {
  FormatData(value, suffix = "%", places = places, decimal = decimalMark)
}

FormatDecimal <- function(value, places = 2) {
  FormatData(value, places = places, decimal = decimalMark)
}

```

```{r Parameters set-up}
# This chunk reads in the parameter input files and coverts them into parameter 
# sets for input into the model simulations

# Currently just using uniform distributions for sampling.  

if (!loadParameters) {
  
  # Read in parameter files
  parametersFixed <- read_csv(file.path(resultsFolder, paste0(saveFileTag,
    "_parameters_fixed.csv")))
  parametersVar <- read_csv(file.path(resultsFolder, paste0(saveFileTag,
    "_parameters_variable.csv")))
  
  # Set-up best fit parameters -------------------------------------------------
  paramsBest <- parametersFixed %>%
    select(code_variable, estimate) %>%
    # Only need these parameters for the model the others are for setting up
    # parameter sets
    filter(code_variable %in% c("effart", "effprep", "effcondom", "annual_cost",
      "lifetime_cost_0d", "lifetime_cost_35d", "lifetime_cost_50d")) %>%
    spread(code_variable, estimate) %>%
    slice(rep(row_number(), nyears)) %>%
    bind_cols(parametersVar) %>%
    mutate(simset = 1) %>%
    select(simset, year, everything())
  
  # Set-up best fit costing vectors 
  costingsBest <- paramsBest %>% 
    select(year, inflation_index, annual_cost, lifetime_cost_0d, 
      lifetime_cost_35d, lifetime_cost_50d) %>%
    mutate(cumulative_index = IndexCPI(inflation_index),
      cumulative_index2 = IndexCPI(MultiplyCPI(inflation_index, 2))) %>%
    mutate(ac_adjusted = cumulative_index * annual_cost,
      lc0_adjusted = cumulative_index *  lifetime_cost_0d, 
      lc35_adjusted = cumulative_index *  lifetime_cost_35d,
      lc50_adjusted = cumulative_index *  lifetime_cost_50d,
      ac_adjusted2 = cumulative_index2 * annual_cost,
      lc0_adjusted2 = cumulative_index2 *  lifetime_cost_0d, 
      lc35_adjusted2 = cumulative_index2 *  lifetime_cost_35d,
      lc50_adjusted2 = cumulative_index2 *  lifetime_cost_50d)
  
  # Generate parameter sets for all simulations --------------------------------
  paramsSets <- list()
  costingSets <- list()
  
  if (numsims > 1) {
    
    # Parameters that are not sampled
    paramsCertain <- c("inflation_index")
    
    # Separate the parameters into two sets those that are inputs in the 
    # model and those that are used to produce uncertainty in the time series 
    # variables. The time series variables need to be sampled twice for the
    # start and end of the time series. 
    params2sampleOnce <- c("effart", "effprep", "effcondom", "annual_cost",
      "lifetime_cost_0d", "lifetime_cost_35d", "lifetime_cost_50d", 
      "inflation_index_factor")
    params2sampletwice <- c("plhiv", "prop_diagnosed", "prop_art", 
      "prop_vs", "prop_prep", "prop_condom", "diagnosed_os", "diagnoses") 
    
    paramsSets[["simset"]] <- rep(1:numsims, each = nyears)
    paramsSets[["year"]] <- rep(years, numsims)
    
    # Fixed parameters
    for (var in params2sampleOnce) {
      # Sample from parameter range and duplicate across years
      temp <- runif(numsims,(parametersFixed %>% filter(code_variable == var))$lower, 
        (parametersFixed %>% filter(code_variable == var))$upper) 
      temp <- rep(temp, each = nyears)
      
      paramsSets[[var]] <- temp
    }
    
    # Time varying parameters - sampled from multiplicative factor range at each 
    # end and then connect linearly to change the best estimate values.  
    for (var in params2sampletwice) {
      
      tempStart <-  runif(numsims,(parametersFixed %>% 
          filter(code_variable == paste0(var, "_range")))$lower, 
        (parametersFixed %>% filter(code_variable == paste0(var,"_range")))$upper)
      tempEnd <- runif(numsims,(parametersFixed %>% 
          filter(code_variable == paste0(var, "_range")))$lower, 
        (parametersFixed %>% filter(code_variable == paste0(var, "_range")))$upper)
      
      # Update best estimate using sampled multiplicative factors for each sim
      varVector <- vector()
      for (ii in 1:numsims) {
        
        varVector <- c(varVector, seq(tempStart[ii], tempEnd[ii], length = nyears) *
            parametersVar[[var]])
        
        paramsSets[[var]] <- varVector
        
      }
    }
    
    for (var in paramsCertain) {
      paramsSets[[var]] <- rep(parametersVar[[var]], numsims)
    }
    
    # Convert to tibble
    paramsSets <- as_tibble(paramsSets)
    
    # Generate costing sets for all simulations 
    for (ii in 1:numsims) {
      tempParams <- paramsSets %>% filter(simset == ii)
      
      tempCosts <- tempParams  %>% 
        select(simset, year, inflation_index, annual_cost, lifetime_cost_0d, 
          lifetime_cost_35d, lifetime_cost_50d) %>%
        mutate(cumulative_index = IndexCPI(inflation_index),
          cumulative_index2 = IndexCPI(MultiplyCPI(inflation_index, 2))) %>%
        mutate(ac_adjusted = cumulative_index * annual_cost,
          lc0_adjusted = cumulative_index *  lifetime_cost_0d, 
          lc35_adjusted = cumulative_index *  lifetime_cost_35d,
          lc50_adjusted = cumulative_index *  lifetime_cost_50d,
          ac_adjusted2 = cumulative_index2 * annual_cost,
          lc0_adjusted2 = cumulative_index2 *  lifetime_cost_0d, 
          lc35_adjusted2 = cumulative_index2 *  lifetime_cost_35d,
          lc50_adjusted2 = cumulative_index2 *  lifetime_cost_50d)
      
      costingSets <- bind_rows(costingSets, tempCosts)
      
    }
  } # Else paramsSets and costingSets are NULL
  
  # Save parameters in a separate file
  if (saveProject) {
    save(parametersFixed, parametersVar, paramsBest, paramsSets, costingsBest, 
      costingSets, file = file.path(resultsFolder, 
        paste0(loadFileTag, "_parameters.Rda")))
  }
  
} else {
  # Load parmaeter sets from file - paramsBest, paramsSets
  load(file.path(resultsFolder, paste0(loadFileTag, "_parameters.Rda")))
}

```

```{r Analysis functions}
# This functions and the key functions used for the analysis. 

# Main function ----------------------------------------------------------------
# This is the main function for the analysis calculating the number of new
# infections for a given year from the input data
NewInfections <- function(plhiv, beta, propdiag, propart, propvs, 
  effart, propprep, effprep, condom0, condomt, effcondom) {
  
  return(plhiv * beta *(1 - propdiag * propart*propvs*effart) * 
      (1 - propprep * effprep) * (1 - effcondom * condomt) / 
      (1 - effcondom * condom0))
}

# Beta calculation function ----------------------------------------------------
# Define a function to calculate beta given a new infections estimate and other 
# parameter values. This is used at the initial time point using available data
# for the starting year (startYear). This values of beta is than used in the
# simulations. 

Beta <- function(incidence, plhiv, propdiag, propart, propvs, effart,
  propprep, effprep){
  return(incidence / (plhiv * (1 - propdiag * propart * propvs * effart) * 
      (1 - propprep * effprep)))
}

# Simulation function ----------------------------------------------------------

simulate <- function(numyears, paramsDf) {
  
  # Initialize results variables
  infected <- rep(0, numyears)
  newInfects <- rep(0, numyears)
  diagnosed <- rep(0, numyears)
  numArt <- rep(0, numyears)
  
  newInfects[1] <- paramsDf$diagnoses[1]
  infected[1] <- paramsDf$plhiv[1] 
  diagnosed[1] <- infected[1] * paramsDf$prop_diagnosed[1]
  numArt[1] <- diagnosed[1] * paramsDf$prop_art[1]
  
  betaValue <- Beta(newInfects[1], infected[1], 
    paramsDf$prop_diagnosed[1],
    paramsDf$prop_art[1], paramsDf$prop_vs[1],
    paramsDf$effart[1], paramsDf$prop_prep[1], paramsDf$effprep[1])
  
  for (ii in 2:numyears) {
    
    infected[ii] <- infected[ii-1] + newInfects[ii-1] + paramsDf$diagnosed_os[ii]
    
    newInfects[ii] <- NewInfections(infected[ii], 
      betaValue,
      paramsDf$prop_diagnosed[ii],
      paramsDf$prop_art[ii], paramsDf$prop_vs[ii], paramsDf$effart[ii], 
      paramsDf$prop_prep[ii], paramsDf$effprep[ii], 
      paramsDf$prop_condom[1], paramsDf$prop_condom[ii], 
      paramsDf$effcondom[ii])
    
    diagnosed[ii] <- infected[ii] * paramsDf$prop_diagnosed[ii]
    numArt[ii] <- diagnosed[ii] * paramsDf$prop_art[ii]
  }
  
  results <- tibble(
    infected = infected,
    newInfects = newInfects,
    diagnosed = diagnosed,
    numArt = numArt)
  
  return(results)
}

```

**Table 1** - Fixed input parameter estimates and ranges. Endnotes provide
justifications for these parameter values. The simulations used for the
calculations take samples from these ranges assuming a uniform distribution.

| Parameter                       | Description                                                                                                                                                                                                                                                                                                                                                  | Estimate and Range                                                                                                                                                                                                                                                        | Notes |
|--------------------|--------------------|---------------------|--------------------|
| $N(0)$                          | Number of people living with HIV in 2009                                                                                                                                                                                                                                                                                                                     | `r FormatData(parametersVar$plhiv[1], parametersVar$plhiv[1]*(parametersFixed %>% filter(code_variable == "plhiv_range"))$lower, parametersVar$plhiv[1]*(parametersFixed %>% filter(code_variable == "plhiv_range"))$upper, places = 0)`                                  | 1     |
| **HIV transmission parameters** |                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                           |       |
| $\beta$                         | Annual probability an untreated person transmits HIV to another person                                                                                                                                                                                                                                                                                       | Calculated using initial values                                                                                                                                                                                                                                           | 2     |
| $\epsilon_{ART}$                | Efficacy of ART in preventing HIV transmission if virus is suppressed                                                                                                                                                                                                                                                                                        | `r FormatData((parametersFixed %>% filter(code_variable == "effart"))$estimate, (parametersFixed %>% filter(code_variable == "effart"))$lower, (parametersFixed %>% filter(code_variable == "effart"))$upper)`                                                            | 3     |
| $\epsilon_{PrEP}$               | Efficacy of PrEP in preventing HIV transmission                                                                                                                                                                                                                                                                                                              | `r FormatData((parametersFixed %>% filter(code_variable == "effprep"))$estimate, (parametersFixed %>% filter(code_variable == "effprep"))$lower, (parametersFixed %>% filter(code_variable == "effprep"))$upper)`                                                         | 4     |
| $\epsilon_{condom}$             | Efficacy of condoms in preventing HIV transmission                                                                                                                                                                                                                                                                                                           | `r FormatData((parametersFixed %>% filter(code_variable == "effcondom"))$estimate, (parametersFixed %>% filter(code_variable == "effcondom"))$lower, (parametersFixed %>% filter(code_variable == "effcondom"))$upper)`                                                   | 5     |
| **HIV treatment costs**         |                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                           |       |
| $c_{ART}$                       | Average annual cost of providing care and ART in 2019 AUD                                                                                                                                                                                                                                                                                                    | `r FormatData((parametersFixed %>% filter(code_variable == "annual_cost"))$estimate, (parametersFixed %>% filter(code_variable == "annual_cost"))$lower, (parametersFixed %>% filter(code_variable == "annual_cost"))$upper, places = 0, prefix = "$")`                   | 6     |
| $c^0_{life}$                    | Undiscounted lifetime cost of providing care and ART post infection in 2019 AUD                                                                                                                                                                                                                                                                              | `r FormatData((parametersFixed %>% filter(code_variable == "lifetime_cost_0d"))$estimate, (parametersFixed %>% filter(code_variable == "lifetime_cost_0d"))$lower, (parametersFixed %>% filter(code_variable == "lifetime_cost_0d"))$upper, places = 0, prefix = "$")`    | 7     |
| $c^{3.5}_{life}$                | Lifetime cost of providing care and ART post infection in 2019 AUD discounted 3.5% `r FormatData((parametersFixed %>% filter(code_variable == "lifetime_cost_35d"))$estimate, (parametersFixed %>% filter(code_variable == "lifetime_cost_35d"))$lower, (parametersFixed %>% filter(code_variable == "lifetime_cost_35d"))$upper, places = 0, prefix = "$")` | 7                                                                                                                                                                                                                                                                         |       |
| $c^5_{life}$                    | Lifetime cost of providing care and ART post infection in 2019 AUD discounted 5%                                                                                                                                                                                                                                                                             | `r FormatData((parametersFixed %>% filter(code_variable == "lifetime_cost_50d"))$estimate, (parametersFixed %>% filter(code_variable == "lifetime_cost_50d"))$lower, (parametersFixed %>% filter(code_variable == "lifetime_cost_50d"))$upper, places = 0, prefix = "$")` | 7     |

1.  

2.  

3.  

4.  

5.  

6.  

7.  

\newpage

<!--- Manipulate the time varying parameters into a table--->

```{r Format time varying parameters}
table2 <- parametersVar %>%
  gather(key = var_name, value = value, 2:ncol(.)) %>% 
  spread(key = names(.)[1],value = 'value') %>%
  mutate("Assumed uncertainty range" = NA,
    "References" = NA) 

table2Caption <- "Time varying input parameter estimates. Endnotes provide
references and justifications. The values for PLHIV and diagnoses are not used in
the calculations, rather they are used for validation."

```

```{r Table2}
#| label: tbl-table2
#| tbl-cap: !expr table2Caption 
#| tbl-cap-location: top # Doesn't seem to work
#| include: true
#| output: asis
knitr::kable(table2, row.names = FALSE, 
  caption = "Caption for cross-ref delete {#tbl-table2}")
```

\newpage

## Results

```{r Run simulations - baseline}

if (!loadResults) {
  
  # Best estimate results --------------------------------------------------------
  
  resultsBest <- simulate(nyears, paramsBest) %>%
    mutate(year = years) %>%
    select(year, everything())
  
  # Simulation sets results ------------------------------------------------------
  
  resultsSims <- tibble()
  
  if (numsims > 1) {
    
    for (ii in 1:numsims) {
      
      paramsSim <- paramsSets %>% filter(simset == ii)
      
      resultsSim <- simulate(nyears, paramsSim) %>% 
        mutate(simset = ii, year = years) %>%
        select(simset, year, everything())
      
      resultsSims <- resultsSims %>% bind_rows(resultsSim)
      
    }
  }
  
  # Save parameters in a separate file
  if (saveProject) {
    save(resultsBest, resultsSims, file = file.path(resultsFolder, 
      paste0(loadFileTag, "_results.Rda")))
  }
  
} else {
  # Load results from file - resultsBest, resultsSims
  load(file.path(resultsFolder, paste0(loadFileTag, "_results.Rda")))
  
}

```

```{r Plot specifications}

# Choose some colours for plotting
dput(PlotColors("crayons")[c("Black", "Gray", "Blue", "Cornflower", "Red", "Melon")])

plotcols <- c(Black = "#000000", Gray = "#95918c", Blue = "#1f75fe", 
  Cornflower = "#9aceeb", Red = "#ee204d", Melon = "#fdbcb4")

# Function to extract hex values
pc <- function(col) unname(plotcols[col])

# Set up figure sizes in document - in inches for Knitr chunk headers
figWidth <- 22/2.5
figRowWidth <- 8/2.5

```

```{r Validation}
# Compare the baseline results to available data - plot of plhiv and diagnoses 
# vs new infections

# Extract results --------------------------------------------------------------
validationData <- paramsBest %>% select(year, plhiv, diagnoses)

plhivPlot <- ggplot(data = resultsSims, 
  aes(x = year, y = infected, group = simset)) + 
  geom_line(aes(colour = "sims")) +
  geom_line(data = resultsBest, aes(group = 1, colour = "best")) +
  geom_point(data = validationData, aes(y = plhiv, group = 1, color = "data")) +
  expand_limits(y = c(0, NA)) + 
  scale_x_continuous(breaks = seq(2009, 2019, by = 2)) + 
  scale_colour_manual(name = "", 
    breaks = c("data", "best", "sims"), 
    values = c(pc("Black"), pc("Blue"), pc("Cornflower")),
    labels = c("HIV cascade results","Best estimate", "Simulation range")) +
  xlab("Year") + ylab("Number of people with HIV") + 
  PlotOptions()

infectionsPlot <- ggplot(data = resultsSims, 
  aes(x = year, y = newInfects, group = simset)) + 
  geom_line(aes(colour = "sims")) +
  geom_line(data = resultsBest, aes(group = 1, colour = "best")) +
  geom_point(data = validationData, aes(y = diagnoses, group = 1, color = "data")) +
  expand_limits(y = c(0, NA)) + 
  scale_x_continuous(breaks = seq(2009, 2019, by = 2)) + 
  scale_colour_manual(name = "", 
    breaks = c("data", "best", "sims"), 
    values = c(pc("Black"), pc("Blue"), pc("Cornflower")),
    labels = c("New diagnoses","Best estimate", "Simulation range")) +
  xlab("Year") + ylab("Annual HIV infections") + 
  PlotOptions()

if (savePlots) {
  
  SaveFigure(file.path(resultsFolder, "figures"), 
    paste0("PLHIV_Validation_", loadFileTag), 
    plhivPlot, format = saveFormat)
  
  SaveFigure(file.path(resultsFolder, "figures"), 
    paste0("Infections_Validation_", loadFileTag), 
    infectionsPlot, format = saveFormat)
  
}
```

```{r Run simulations - scenario}

# Produce and run a scenario where the prop on ART remained at the 2010 level

if (!loadResults) {
  
  scenarioBest <- paramsBest %>%
    mutate(prop_art = ifelse(year > indexYearART, 
      filter(., year == indexYearART)$prop_art, prop_art))
  
  # Best estimate scenario results ---------------------------------------------
  resultsScenarioBest <- simulate(nyears, scenarioBest) %>%
    mutate(year = years) %>%
    select(year, everything())
  
  # Simulation set scenario results --------------------------------------------
  
  resultsScenarioSims <- tibble()
  
  if (numsims > 1) {
    
    for (ii in 1:numsims) {
      
      ScenarioSim <- paramsSets %>% filter(simset == ii) %>%
        mutate(prop_art = ifelse(year > indexYearART, 
          filter(., year == indexYearART)$prop_art, prop_art))
      
      resultsScenarioSim <- simulate(nyears, ScenarioSim) %>% 
        mutate(simset = ii, year = years) %>%
        select(simset, year, everything())
      
      resultsScenarioSims <- resultsScenarioSims %>% bind_rows(resultsScenarioSim)
      
    }
  }
  
  # Save parameters in a separate file
  if (saveProject) {
    save(resultsBest, resultsSims, resultsScenarioBest, resultsScenarioSims, 
      file = file.path(resultsFolder, paste0(loadFileTag, "_results.Rda")))
  }
  
} else {
  # Load results from file - resultsBest, resultsSims, 
  # resultsScenarioBest, resultsScenarioSims
  load(file.path(resultsFolder, paste0(loadFileTag, "_results.Rda")))
}

```

```{r Analyse epi results and generate plots}

# Organize results for analysis and plotting------------------------------------
scenarioResultsBest <- (resultsBest %>% mutate(scenario = "base")) %>%
  bind_rows(resultsScenarioBest %>% mutate(scenario = "scenario")) %>%
  select(scenario, year, everything())

scenarioResultsSims <- (resultsSims %>% mutate(scenario = "base")) %>%
  bind_rows(resultsScenarioSims %>% mutate(scenario = "scenario")) %>%
  select(scenario, simset, year, everything())

# Generate plots ---------------------------------------------------------------
resultsPlhiv <- ggplot(data = scenarioResultsSims, aes(x = year, y = infected, 
  colour = scenario, fill = scenario, group = interaction(scenario, simset))) + 
  geom_line() +
  # geom_ribbon(aes(ymin = quantile(infected, 0.025), 
  #   ymax = quantile(infected, 0.975))) + 
  geom_line(data = (scenarioResultsBest %>% filter(scenario == "base")), 
    aes(group = 1), colour = pc("Blue"), size = 1.1) +
  geom_line(data = (scenarioResultsBest %>% filter(scenario == "scenario")), 
    aes(group = 1), colour = pc("Black"), size = 1.1) +
  expand_limits(y = c(0, NA)) + 
  scale_x_continuous(breaks = seq(2009, 2019, by = 2)) + 
  scale_colour_manual(name = "", 
    breaks = c("base", "scenario"), 
    values = c(pc("Cornflower"), pc("Gray")),
    labels = c("U=U scenario", "No increase ART")) +
  xlab("Year") + ylab("Number of people with HIV") + 
  PlotOptions()

resultsInfects <- ggplot(data = scenarioResultsSims, aes(x = year, y = newInfects, 
  colour = scenario, group = interaction(scenario, simset))) + 
  geom_line() + 
  geom_line(data = (scenarioResultsBest %>% filter(scenario == "base")), 
    aes(group = 1), colour = pc("Blue"), size = 1.1) +
  geom_line(data = (scenarioResultsBest %>% filter(scenario == "scenario")), 
    aes(group = 1), colour = pc("Black"), size = 1.1) +
  expand_limits(y = c(0, NA)) + 
  scale_x_continuous(breaks = seq(2009, 2019, by = 2)) + 
  scale_colour_manual(name = "", 
    breaks = c("base", "scenario"), 
    values = c(pc("Cornflower"), pc("Gray")),
    labels = c("U=U scenario", "No increase ART")) +
  xlab("Year") + ylab("Annual HIV infections") + 
  PlotOptions()

# Cumulative infections --------------------------------------------------------

cumInfects <- scenarioResultsSims %>% 
  group_by(simset, scenario) %>%
  summarise(infections = sum(newInfects)) %>%
  ungroup()

resultsCumInfects <- ggplot(data = cumInfects, aes(x = scenario, y = infections)) + 
  geom_boxplot(aes(fill = scenario), width = 0.75, alpha = 0.5) +
  scale_fill_manual(
    labels = c("base", "scenario"), 
    values = c(pc("Black"), pc("Cornflower"))) +
  xlab("") + ylab("Cumulative infections") +
  scale_x_discrete(labels = c("U=U scenario", "No increase ART")) +
  expand_limits(y = c(0, NA)) + 
  PlotOptions() + theme(legend.position = "none")

# Histogram of averted infections ----------------------------------------------

avertedInfects <- cumInfects %>% 
  spread(scenario, infections) %>%
  mutate(averted = scenario - base)

resultsAverted <- ggplot(data = avertedInfects, aes(x = averted)) +
  geom_density(alpha = 0.5, fill = pc("Cornflower")) +
  xlab("Infections averted") + ylab("Density") +
  PlotOptions() + theme(legend.position = "none")  

# Save plots separately --------------------------------------------------------

if (savePlots) {
  
  SaveFigure(file.path(resultsFolder, "figures"), 
    paste0("Scenario_PLHIV_", loadFileTag), 
    resultsPlhiv, format = saveFormat)
  
  SaveFigure(file.path(resultsFolder, "figures"), 
    paste0("Scenario_infections_", loadFileTag),
    resultsInfects, format = saveFormat)
  
  SaveFigure(file.path(resultsFolder, "figures"), 
    paste0("Scenario_cumulative_infections_", loadFileTag),
    resultsCumInfects, format = saveFormat)
  
  SaveFigure(file.path(resultsFolder, "figures"), 
    paste0("Scenario_averted_infections", loadFileTag),
    resultsAverted, format = saveFormat)
}


```

```{r Health Economic Calculations}
# This chunk does the health economic calculations -- we apply costs to all 
# diagnosed not just those on ART (conservative costing)

if (!loadResults) {

  HEresultsBest <- scenarioResultsBest %>% 
    select(scenario, year, numArt, newInfects) %>% 
    left_join(costingsBest, by = "year") %>% # Duplicate for both scenarios 
    mutate(
      hc_base = numArt * annual_cost,
      hc_adjusted = numArt * ac_adjusted,
      hc_adjusted2 = numArt * ac_adjusted2,
      lc0 = newInfects * lifetime_cost_0d,
      lc35 = newInfects * lifetime_cost_35d,
      lc50 = newInfects * lifetime_cost_50d,
      lc0_adjusted = newInfects * lc0_adjusted,
      lc35_adjusted = newInfects * lc35_adjusted,
      lc50_adjusted = newInfects * lc50_adjusted,
      lc0_adjusted2 = newInfects * lc0_adjusted2,
      lc35_adjusted2 = newInfects * lc35_adjusted2,
      lc50_adjusted2 = newInfects * lc50_adjusted2) %>%
    select(scenario, year, numArt, newInfects, contains("hc"),
      contains("lc")) 
  
  cumHEresultsBest <- HEresultsBest %>%
    select(-year, -numArt) %>%
    group_by(scenario) %>% 
    summarise_all(sum)
  
  HEresultsSims <- tibble()
  cumHEresultsSims <- tibble()
  
  if (numsims > 1) {
    
    HEresultsSims <- scenarioResultsSims %>% 
      select(scenario, simset, year, numArt, newInfects) %>% 
      left_join(costingsBest, by = "year") %>% # Duplicate for both scenarios
      mutate(
        hc_base = numArt * annual_cost,
        hc_adjusted = numArt * ac_adjusted,
        hc_adjusted2 = numArt * ac_adjusted2,
        lc0 = newInfects * lifetime_cost_0d,
        lc35 = newInfects * lifetime_cost_35d,
        lc50 = newInfects * lifetime_cost_50d,
        lc0_adjusted = newInfects * lc0_adjusted,
        lc35_adjusted = newInfects * lc35_adjusted,
        lc50_adjusted = newInfects * lc50_adjusted,
        lc0_adjusted2 = newInfects * lc0_adjusted2,
        lc35_adjusted2 = newInfects * lc35_adjusted2,
        lc50_adjusted2 = newInfects * lc50_adjusted2) %>%
      select(scenario, simset, year, numArt, newInfects, contains("hc"),
        contains("lc")) 
    
    cumHEresultsSims <- HEresultsSims %>%
      select(-year, -numArt) %>%
      group_by(scenario, simset) %>% 
      summarise_all(sum)
    
  }
  
  # Save parameters in a separate file
  if (saveProject) {
    save(resultsBest, resultsSims, resultsScenarioBest, resultsScenarioSims, 
      HEresultsBest, cumHEresultsBest, HEresultsSims, cumHEresultsSims, 
      file = file.path(resultsFolder, paste0(loadFileTag, "_results.Rda")))
  }
  
} else {
  # Load results from file - resultsBest, resultsSims, 
  # resultsScenarioBest, resultsScenarioSims
  load(file.path(resultsFolder, paste0(loadFileTag, "_results.Rda")))
}

```

```{r Health economic plots}
# Health economics bar charts --------------------------------------------------

# Set-up results for plot
barResultsBest <- cumHEresultsBest %>%
  select(hc_adjusted, lc0_adjusted, lc35_adjusted, lc50_adjusted) %>%
  summarise(hc_extra = -diff(hc_adjusted),
    lc0= diff(lc0_adjusted),
    lc35 = diff(lc35_adjusted),
    lc50 = diff(lc50_adjusted)) %>%
  gather("indicator", "cost", 1:4)

barResultsSims <- cumHEresultsSims %>% 
  select(simset, hc_adjusted, lc0_adjusted, lc35_adjusted, 
    lc50_adjusted) %>%
  group_by(simset) %>%
  mutate(hc_extra = -diff(hc_adjusted),
    lc0= diff(lc0_adjusted),
    lc35 = diff(lc35_adjusted),
    lc50 = diff(lc50_adjusted)) %>%
  ungroup() %>% 
  select(hc_extra, lc0, lc35, lc50) %>%
  gather("indicator", "cost", 1:4) %>%
  group_by(indicator) %>%
  summarise(mean = mean(cost),
    median = median(cost),
    min = min(cost),
    max = max(cost),
    iqr_lower = quantile(cost, 0.25),
    iqr_upper = quantile(cost, 0.75),
    lower95 = quantile(cost, 0.025),
    upper95 = quantile(cost, 0.975))

HEplot <- ggplot(data = barResultsBest , aes(x = indicator, y = cost / 1e6)) +
  geom_col(aes(fill = indicator), width = 0.5, alpha = 0.5) +
  geom_errorbar(data = barResultsSims, aes(y = median / 1e6, 
    ymin = lower95 / 1e6, ymax = upper95 / 1e6),
    colour = "black", width = 0.25, size = 1.1) + 
  scale_fill_manual(name = "",
    values = c(pc("Gray"), pc("Cornflower"), pc("Cornflower"),
    pc("Cornflower"))) +
  xlab("") + ylab("Millions AUD") +
  scale_x_discrete(labels = c("Additional\ntreatment\ncosts",
    "Reduction\n in lifetime\nHIV costs\n(no discounting)",
    "Reduction\n in lifetime\nHIV costs\n(3.5% discounting)",
    "Reduction\n in lifetime\nHIV costs\n(5% discounting)")) +
  ylim(0, 1200) +
  geom_vline(aes(xintercept = 1.5), linetype = "longdash") +
  PlotOptions() + theme(legend.position = "none")

if (savePlots) {
  
  SaveFigure(file.path(resultsFolder, "figures"), 
    paste0("Scenario_HE_Results_", loadFileTag), 
    HEplot, format = saveFormat)
  
}

```

```{r Save paper output}
# Create and save the final plots and tables for the manuscript

# Create a combination plot for the main manuscript 
combinedPlot <- plot_grid(resultsPlhiv, resultsInfects, resultsCumInfects, HEplot,
   ncol = 2, nrow = 2, align = "v", labels = c("A", "B", "C", "D"))

# Create a validation plot for the supplementary material

validationPlot <- plot_grid(plhivPlot, infectionsPlot, 
  ncol = 2, nrow = 1, labels = c("A", "B"))

if (savePlots) {
  
  SaveFigure(file.path(resultsFolder, "figures"), 
    paste0("Combined_Figure_", loadFileTag), 
    combinedPlot, format = saveFormat, 
    width = figWidth, height = figWidth, units = "in")
  
  SaveFigure(file.path(resultsFolder, "figures"), 
    paste0("Validation_Figure_", loadFileTag), 
    validationPlot, format = saveFormat, 
    width = figWidth, height = figWidth/2, units = "in")
  
}

combinedPlotCaption <- "Blah"

validationPlotCaption <- "Blah"

# Create a formatted summary results table for manuscript ----------------------

lprob <- 0.025 # lower and upper probs for quantile function - 95% percentile interval
uprob <- 0.975

# Functions to simply table generation
Format2019 <- function(option, indicator, digits = 0, rangestr = "") {
  FormatData(
    (scenarioResultsBest %>% filter(scenario == option, year == 2019))[[indicator]], 
    quantile((scenarioResultsSims %>% filter(scenario == option, year == 2019))[[indicator]], 
      probs = lprob), 
    quantile((scenarioResultsSims %>% filter(scenario == option, year == 2019))[[indicator]], 
      probs = uprob),
    places = digits, rangestr = rangestr)
}

FormatCumulative <- function(option, digits = 0, rangestr = "") {
  FormatData(
    (scenarioResultsBest %>% filter(scenario == option))$newInfects %>% sum(), 
    quantile(cumInfects[[option]], probs = lprob), 
    quantile(cumInfects[[option]], probs = uprob),
    places = digits, rangestr = rangestr)
}

FormatCosts <- function(option, indicator, digits = 0, scale = 0){
  FormatData(
    (cumHEresultsBest %>% filter(scenario == option))[[indicator]] / (10^scale),
    quantile((cumHEresultsSims %>% filter(scenario == option))[[indicator]] / (10^scale), 
      probs = lprob), 
    quantile((cumHEresultsSims %>% filter(scenario == option))[[indicator]] / (10^scale), 
      probs = uprob),
    places = digits, prefix = "$")
}

# Calculate cost differences 
costDifferences <- cumHEresultsSims %>%
  group_by(simset) %>%
  select(-scenario) %>%
  summarise(across(everything(), diff)) %>%
  ungroup() %>%
  select(-simset)

FormatCostDiffs <- function(indicator, digits = 0, scale = 0, flip = 1){
  FormatData(
    flip * (cumHEresultsBest %>% filter(scenario == "scenario"))[[indicator]] / (10^scale) -
      flip * (cumHEresultsBest %>% filter(scenario == "base"))[[indicator]] / (10^scale),
    quantile(flip * costDifferences[[indicator]] / (10^scale), probs = lprob), 
    quantile(flip * costDifferences[[indicator]] / (10^scale), probs = uprob),
    places = digits, prefix = "$")
}

# Create summary results table -------------------------------------------------
summaryTable <- tibble(Indicator = character(),
  status_quo =  character(),
  counterfactual = character()) %>%
   bind_rows(tibble(
    Indicator = "People with HIV in 2019",
    status_quo = Format2019("base", "infected"), 
    counterfactual = Format2019("scenario", "infected"))) %>%
  bind_rows(tibble(
    Indicator = "New infections in 2019",
    status_quo = Format2019("base", "newInfects"), 
    counterfactual = Format2019("scenario", "newInfects"))) %>%
  bind_rows(tibble(
    Indicator = "Cumulative infections",
    status_quo = FormatCumulative("base"), 
    counterfactual = FormatCumulative("scenario"))) %>%
  bind_rows(tibble(
    Indicator = "Infections averted",
    status_quo =  FormatData(
    (scenarioResultsBest %>% filter(scenario == "scenario"))$newInfects %>% sum() - 
         (scenarioResultsBest %>% filter(scenario == "base"))$newInfects %>% sum(), 
    quantile(avertedInfects$averted, probs = lprob), 
    quantile(avertedInfects$averted, probs = uprob),
    places = 0), 
    counterfactual = NA)) %>%
  bind_rows(tibble(
    Indicator = "Total treatment costs (inflated by CPI)", 
    status_quo = FormatCosts("base", "hc_adjusted", scale = 6),
    counterfactual = FormatCosts("scenario", "hc_adjusted", scale = 6))) %>%
  bind_rows(tibble(
    Indicator = "Additional Treatment costs (inflated by CPI)", 
    status_quo = FormatCostDiffs("hc_adjusted", flip = -1, scale = 6),
    counterfactual = NA)) %>%
  bind_rows(tibble(
    Indicator = "Lifetime HIV care and treatment costs (discounted 3.5%)", 
    status_quo = FormatCosts("base", "lc35_adjusted", scale = 6),
    counterfactual = FormatCosts("scenario", "lc35_adjusted", scale = 6))) %>%
  bind_rows(tibble(
    Indicator = "Reduction in HIV care and treatment costs (discounted 3.5%)", 
    status_quo = FormatCostDiffs("lc35_adjusted", flip = -1, scale = 6),
    counterfactual = NA)) %>%
  # Reorganize columns and rename
  select(Indicator, "No ART increase" = counterfactual, "Status-quo (U=U era)" = status_quo)

if (savePlots) {
  
  write_csv(summaryTable, file.path(resultsFolder, "figures", 
    paste0("Summary_Results_", loadFileTag, ".csv")))
  
}

summaryTableCaption <- "Blah"

# Create a scenario table for the HE results -----------------------------------
costSummaryTable <- tibble(
  "Cost indicator" = character(4),
  "No inflation" = character(4),
  "Observed CPI" = character(4),
  "Double CPI" = character(4)) 

costSummaryTable[["Cost indicator"]] <- c("Additional treatment costs",
  "Reduction in lifetime HIV costs (no discounting)", 
  "Reduction in lifetime HIV costs (3.5% discounting)",
  "Reduction in lifetime HIV costs (5% discounting)")

costSummaryTable[["No inflation"]] <- c(
  FormatCostDiffs("hc_base", flip = -1, scale = 6),
  FormatCostDiffs("lc0", scale = 6),
  FormatCostDiffs("lc35", scale = 6),
  FormatCostDiffs("lc50", scale = 6))

costSummaryTable[["Observed CPI"]] <- c(
  FormatCostDiffs("hc_adjusted", flip = -1, scale = 6),
  FormatCostDiffs("lc0_adjusted", scale = 6),
  FormatCostDiffs("lc35_adjusted", scale = 6),
  FormatCostDiffs("lc50_adjusted", scale = 6))

costSummaryTable[["Double CPI"]] <- c(
  FormatCostDiffs("hc_adjusted2", flip = -1, scale = 6),
  FormatCostDiffs("lc0_adjusted2", scale = 6),
  FormatCostDiffs("lc35_adjusted2", scale = 6),
  FormatCostDiffs("lc50_adjusted2", scale = 6))

if (savePlots) {
  
  write_csv(costSummaryTable, file.path(resultsFolder, "figures", 
    paste0("Summary_costs_", loadFileTag, ".csv")))
  
}

costTableCaption <- "Blah"

```

**Abstract Results**:



**Main results**

The model estimates under the baseline scenario that the number of people living
with HIV in 2019 was 
`r Format2019("base", "infected", rangestr = "95% PI: ")`
with 
`r Format2019("base", "newInfects", rangestr = "95% PI: ")` 
new infections. This closely aligns with estimates from the Australian HIV
cascade which estimates there were 21,400 (range: 18,520-24,440) people living
with HIV in 2019.[@institute_hiv_2022] The number of new infections from the
model calculations was lower over 2009-2019 but comparable to the number of new
notifications excluding those previously diagnosed overseas (598 notifications
in 2019 with a peak of 807 in 2014 [@institute_hiv_2022]). See Figure
@fig-figureS1 in the supplementary material. This shows our model has good
validity for estimating the number of people taking ART and the number of new
infections over the analysis period.


If there was no increase in ART since
`r project$projectVars$indexYearART`
(the counter factual scenario) the model estimates there would have have been
`r Format2019("scenario", "infected", rangestr = "95% PI: ")`
people living with HIV in 2019 (@fig-figure1 A) and 
`r Format2019("scenario", "newInfects", rangestr = "95% PI: ")`
new HIV infections (@fig-figure1 B). These are 
`r FormatPercent(100 *((scenarioResultsBest %>% filter(year == 2019))$infected[2]/ (scenarioResultsBest %>% filter(year == 2019))$infected[1] - 1))` 
and 
`r FormatPercent(100 *((scenarioResultsBest %>% filter(year == 2019))$newInfects[2]/ (scenarioResultsBest %>% filter(year == 2019))$newInfects[1] - 1))` 
higher, respectively,  
than for the baseline scenario. Cumulatively we estimate there were
`r FormatCumulative("base", rangestr = "95% PI: ")`
and 
`r FormatCumulative("scenario", rangestr = "95% PI: ")`
new HIV infections for the baseline and counter factual scenarios, respectively,
over 2009-2019 (@fig-figure1 C). This implies the increase in ART coverage since
the start of the treatment as prevention era could have averted an additional
`r FormatData((scenarioResultsBest %>% group_by(scenario) %>% summarise(infections = sum(newInfects)))$infections %>% diff(), quantile(avertedInfects$averted, probs = lprob),  quantile(avertedInfects$averted, probs = uprob), places = 0, rangestr = "95% PI: ")`
new HIV infections. 

* Paragraph on costing results. 

## Discussion

## Conflicts of Interest

## Acknowledgements

## References

::: {#refs}
:::

\newpage

## Tables

<!--- Inserted using code chunks and the loaded results --->

```{r Table 3}
#| label: tbl-table3
#| tbl-cap: !expr summaryTableCaption 
#| tbl-cap-location: top # Doesn't seem to work
#| include: true
#| output: asis
knitr::kable(summaryTable, row.names = FALSE, 
  caption = "Caption for cross-ref delete {#tbl-table3}")
```

\newpage

```{r Table 4}
#| label: tbl-table4
#| tbl-cap: !expr costTableCaption 
#| tbl-cap-location: top # Doesn't seem to work
#| include: true
#| output: asis
knitr::kable(costSummaryTable, row.names = FALSE, 
  caption = "Caption for cross-ref delete {#tbl-table4}")
```

## Figures and Figure Legends

<!--- Inserted using code chunks and the loaded results --->

```{r Figure 1}
#| label: fig-figure1
#| include: true
#| fig-cap: !expr combinedPlotCaption
#| fig-cap-location: top # Doesn't seem to work
#| fig-width: !expr figWidth
#| fig-height: !expr 2*figRowWidth
print(combinedPlot)
```

## Supplementarty Material

### Validation of calculations

```{r Figure S1}
#| label: fig-figureS1
#| include: true
#| fig-cap: !expr combinedPlotCaption
#| fig-cap-location: top # Doesn't seem to work
#| fig-width: !expr figWidth
#| fig-height: !expr 2*figRowWidth
print(validationPlot)
```

### Retrospective adjustement of cost ings for 20-19


